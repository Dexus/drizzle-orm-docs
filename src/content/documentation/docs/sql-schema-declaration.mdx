import Tab from '@components/markdown/Tab.astro';
import Tabs from '@components/markdown/Tabs.astro';
import Callout from '@components/markdown/Callout.astro';
import SimpleLinkCards from '@components/markdown/SimpleLinkCards.astro';
import CodeTabs from "@mdx/CodeTabs.astro";
import Section from '@components/markdown/Section.astro';

1. schema files 
2. declaring schema in typescript
3. 
3. schemas in databases(pg, mysql, sqlite)
4. casing


# Overview

Drizzle lets you define a schema in TypeScript with various models and properties supported by the underlying database. 
When you define your schema, it serves as the source of truth for future modifications in queries (using Drizzle-ORM)
and migrations (using Drizzle-Kit).

<Callout> 
If you are using Drizzle-Kit for the migration process, make sure to export all the models defined in your schema files so that Drizzle-Kit can import them and use them in the migration diff process. 
</Callout>
\
Here is how Drizzle will work with your schema:

**Querying Process**

- Define your schema in a TypeScript file.
- Import the schema into any file where you are performing queries.
- Use table models in queries

**Migration Process**

- Define your schema in a TypeScript file.
- Set up the `drizzle.config.ts` file and point it to your schema (see the explanation below).
- Drizzle-Kit will import all your models and automatically generate SQL migration files or statements.


## Organize your schema files 
You can declare your SQL schema directly in TypeScript either in a single `schema.ts` file,
or you can spread them around â€” whichever you prefer, all the freedom!

#### Schema in 1 file
The most common way to declare your schema with Drizzle is to put all your tables into one `schema.ts` file.

> Note: You can name your schema file whatever you like. For example, it could be `models.ts`, or something else.

This approach works well if you don't have too many table models defined, or if you're okay with keeping them all in one file

Example:
    ```plaintext
ðŸ“¦ <project root>
 â”” ðŸ“‚ src
    â”” ðŸ“‚ db
       â”” ðŸ“œ schema.ts
    ```

In the `drizzle.config.ts` file, you need to specify the path to your schema file. With this configuration, Drizzle will 
read from the `schema.ts` file and use this information during the migration generation process. For more information 
about the `drizzle.config.ts` file and migrations with Drizzle, please check: [link]
```ts
import { defineConfig } from "drizzle-kit";

defineConfig({
  dialect: 'postgresql', // 'mysql' | 'sqlite' | 'turso'
  schema: './src/db/schema.ts'
})
```

#### Schema in multiple files

You can place your Drizzle models â€” such as tables, enums, sequences, etc. â€” not only in one file but in any file you prefer. 
The only thing you must ensure is that you export all the models from those files so that the Drizzle kit can import 
them and use them in migrations.

One use case would be to separate each table into its own file.
```plaintext
ðŸ“¦ <project root>
 â”” ðŸ“‚ src
    â”” ðŸ“‚ db
       â”” ðŸ“‚ schema
          â”œ ðŸ“œ users.ts
          â”œ ðŸ“œ countries.ts
          â”œ ðŸ“œ cities.ts
          â”œ ðŸ“œ products.ts
          â”œ ðŸ“œ clients.ts
          â”” ðŸ“œ etc.ts
```

In the `drizzle.config.ts` file, you need to specify the path to your schema folder. With this configuration, Drizzle will 
read from the `schema` folder and find all the files recursively and get all the drizzle tables from there. For more information 
about the `drizzle.config.ts` file and migrations with Drizzle, please check: [link]

```ts
import { defineConfig } from "drizzle-kit";

defineConfig({
  dialect: 'postgresql', // 'mysql' | 'sqlite' | 'turso'
  schema: './src/db/schema'
})
```

You can also group them in any way you like, such as creating groups for user-related tables, messaging-related tables, product-related tables, etc. 
```plaintext
ðŸ“¦ <project root>
 â”” ðŸ“‚ src
    â”” ðŸ“‚ db
       â”” ðŸ“‚ schema
          â”œ ðŸ“œ users.ts
          â”œ ðŸ“œ messaging.ts
          â”” ðŸ“œ products.ts
```

In the `drizzle.config.ts` file, you need to specify the path to your schema file. With this configuration, Drizzle will 
read from the `schema.ts` file and use this information during the migration generation process. For more information 
about the `drizzle.config.ts` file and migrations with Drizzle, please check: [link]

```ts
import { defineConfig } from "drizzle-kit";

defineConfig({
  dialect: 'postgresql', // 'mysql' | 'sqlite' | 'turso'
  schema: './src/db/schema'
})
```

## Shape your data schema

Drizzle schema consists of several model types from database you are using. With drizzle you can specify:
- Tables with columns, constraints, etc.
- Schemas(PostgreSQL only)
- Enums
- Sequences(PostgreSQL only)

Let's go one by one and check how the schema should be defined with drizzle

#### **Tables**, **columns**, **constraints**

Table with Drizzle should be defined with at least 1 column, the same as it should be done in database. There is one important thing to know,
there is no such thing as a commin table object in drizzle. You need to choose a dialect you are using, PostgreSQL, MySQL or SQLite

![](@/assets/images/table-structure.svg)

<CodeTabs items={["PostgreSQL Table", "MySQL Table", "SQLite Table"]}>
```ts copy
import { pgTable, integer } from "drizzle-orm/pg-core"

export const users = pgTable('users', {
  id: integer()
});
```
```ts copy
import { mysqlTable, int } from "drizzle-orm/mysql-core"

export const users = mysqlTable('users', {
  id: int()
});
```
```ts copy
import { sqliteTable, integer } from "drizzle-orm/sqlite-core"

export const users = sqliteTable('users', {
  id: integer()
});
```
</CodeTabs>

#### **Schemas**

<Tabs items={['PostgreSQL', 'MySQL', 'SQLite']}>
<Tab>
\
In PostgreSQL, there is an entity called a `schema` (which we believe should be called `folders`). This creates a structure in PostgreSQL:

![](@/assets/images/postgresql-db-structure.png)

You can manage your PostgreSQL schemas with `pgSchema` and place any other models inside it.

Define the schema you want to manage using Drizzle
```ts
import { pgSchema } from "drizzle-orm/pg-core"

export const customSchema = pgSchema('custom');
```

Then place the table inside the schema object
```ts {5-7}
import { integer, pgSchema } from "drizzle-orm/pg-core";

export const customSchema = pgSchema('custom');

export const users = customSchema.table('users', {
  id: integer()
})
```
</Tab>
<Tab>
\
In MySQL, there is an entity called `Schema`, but in MySQL terms, this is equivalent to a `Database`. 

You can define them with `drizzle-orm` and use them in queries, but they won't be detected by `drizzle-kit` or included in the migration flow

![](@/assets/images/mysql-db-structure.png)

Define the schema you want to manage using Drizzle
```ts
import { mysqlSchema } from "drizzle-orm/mysql-core"

export const customSchema = mysqlSchema('custom');
```

Then place the table inside the schema object
```ts {5-7}
import { int, mysqlSchema } from "drizzle-orm/mysql-core";

export const customSchema = mysqlSchema('custom');

export const users = customSchema.table('users', {
  id: int()
})
```
</Tab>
<Tab>
\
In SQLite, there is no concept of a schema, so you can only define tables within a single SQLite file context

![](@/assets/images/sqlite-db-structure.png)
</Tab>
</Tabs>

### Model Mappings

> This explanation applies to all dialects supported by Drizzle.

By default, Drizzle will use the TypeScript key names for columns in database queries. 
Therefore, the schema and query from the example will generate the SQL query shown below

<Callout>
This example uses a db object, whose initialization is not covered in this part of the documentation. To learn how to connect to the database, please refer to the [Connections Docs]()
</Callout>

\
**TypeScript key = database key**
<Section>
```ts
// schema.ts
import { drizzle } from "drizzle-orm";
import { integer, pgTable, varchar } from "drizzle-orm/pg-core";

export const users = pgTable('users', {
  id: integer(),
  first_name: varchar()
})
```
```ts
// query.ts
await db.select().from(users);
```
```sql
SELECT "id", "first_name" from users;
```
\
If you want to use different names in your TypeScript code and in the database, you can use column aliases

```ts
// schema.ts
import { drizzle } from "drizzle-orm";
import { integer, pgTable, varchar } from "drizzle-orm/pg-core";

export const users = pgTable('users', {
  id: integer(),
  firstName: varchar('first_name')
})
```
```ts
// query.ts
await db.select().from(users);
```
```sql
SELECT "id", "first_name" from users;
```
</Section>

### camelCase and snake_case

Database model names often use `snake_case` conventions, while in TypeScript, it is common to use `camelCase` for naming models. 
This can lead to a lot of alias definitions in the schema. To address this, Drizzle provides a way to automatically 
map `camelCase` from TypeScript to `snake_case` in the database by including one optional parameter during Drizzle database initialization

For such mapping, you can use the `casing` option in the Drizzle DB declaration. This parameter will 
help you specify the database model naming convention and will attempt to map all JavaScript keys accordingly

<Section>
```ts
// schema.ts
import { drizzle } from "drizzle-orm";
import { integer, pgTable, varchar } from "drizzle-orm/pg-core";

export const users = pgTable('users', {
  id: integer(),
  firstName: varchar()
})
```
```ts
// db.ts
const db = await drizzle('node-postgres', { connection: process.env.DATABASE_URL, casing: 'snake_case' })
```
```ts
// query.ts
await db.select().from(users);
```
```sql
SELECT "id", "first_name" from users;
```
</Section>

### Advanced

There are a few tricks you can use with Drizzle ORM. As long as Drizzle is entirely in TypeScript files, 
you can essentially do anything you would in a simple TypeScript project with your code.

One common feature is to separate columns into different places and then reuse them. 
For example, consider the `updated_at`, `created_at`, and `deleted_at` columns. Many tables/models may need these 
three fields to track and analyze the creation, deletion, and updates of entities in a system

We can define those columns in a separate file and then import and spread them across all the table objects you have

<Section>
```ts
// columns.helpers.ts
const timestamps = {
  updated_at: timestamp(),
  created_at: timestamp().defaultNow().notNull(),
  deleted_at: timestamp(),
}
```
```ts
// users.sql.ts
export const users = pgTable('users', {
  id: integer(),
  ...timestamps
})
```
```ts
// posts.sql.ts
export const posts = pgTable('posts', {
  id: integer(),
  ...timestamps
})
```
</Section>

<SimpleLinkCards cards={{
  "PostgreSQL column types": "/docs/column-types/pg",
  "MySQL column types": "/docs/column-types/mysql",
  "SQLite column types": "/docs/column-types/sqlite",
}}/>
